# -*- coding: utf-8 -*-
"""PDI_tarefa01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1krlQ2kkNelzTlGLSuAw8sNJq1KWNPF_N

### FCT-ITEC-UFPA

# Computação gráfica e processamento de imagens
### Nome: Erick Mamede Silva da Costa
### Matrícula: 201906840033
"""



"""## Tarefa 01"""

!git clone https://github.com/erickmamede/PDI.git

# Carrega módulos do Python
import numpy as np                # funções matemáticas 
import matplotlib.pyplot as plt   # traçado de gráficos
import cv2 as cv                  # biblioteca opencv (visão computacional)
from google.colab.patches import cv2_imshow # patch para OpenCV
import scipy                      # funções diversas (processamento de sinais e imagem)


path = '/content/PDI/tarefa_01.jpg' # caminho
nome_da_imagem = 'tarefa_01.jpg' # nome da imagem


##im_colour = cv2.imread( path ) # Lê uma imagem usando opencv

cv2_imshow(im_colour)



"""1. Implementar o filtro 2D uniforme para $L = 3$ e $L = 15$. Para cada um dos filtros, determine a resposta em frequência correspondente. Em seguida, exiba em gráficos 3D as respostas ao impulso e os módulos das respostas em frequência. Interprete e comente os resultados."""

from matplotlib import cm
from matplotlib.ticker import LinearLocator
def filtro2D(L):
  h = np.ones((L,L))  # criação de matriz L x L, todos elementos iguais a 1
  # Exibe a resposta ao impulso 
  h = h/np.sum(h) # normalização (é a versão que iremos usar na filtragem)
  im_output = cv.filter2D( im_gray, -1, h )  # convolução 2D (pesquise o que significa o parâmetro 'ddepth')
  print("Filtro com L = " + str(L))
  #Resposta em frequência
  M = 300                       # número de pontos da FFT
  H = np.fft.fft2(h, [M, M])# calcula a 2D-FFT (transformada rápida de Fourier em duas dimensões)
  H = np.fft.fftshift( H )      # reordena a matriz H (range de -pi a pi)
  H_mag = np.abs(H)             # Calcula a magnitude da resposta em frequência
  print('Respostaem frequencia :')
  print(H_mag)
  
  # Vetores de dados
  u = np.linspace(-np.pi, np.pi, M) # vetor de frequências na direção x
  v = np.linspace(-np.pi, np.pi, M) # vetor de frequências na direção y
  u, v = np.meshgrid(u, v)
  fig, ax = plt.subplots(subplot_kw={"projection": "3d"})

  # Traçado da superfície
  surf = ax.plot_surface(u, v, H_mag, cmap=cm.coolwarm,linewidth=0, antialiased=False)

  plt.show()

im_gray = cv.cvtColor(im_colour, cv.COLOR_BGR2GRAY)  # conversão para escala de cinza (para outros mapas de cores é a mesma função, só muda um parâmetro)
filtro2D(3)
filtro2D(15)

"""2. Para os filtros da questão anterior, determine as respectivas respostas para uma dada imagem de entrada (em níveis de cinza, a sua escolha). Observe o resultado, compare com o resultado da questão anterior, e comente."""

def printfiltro2D(L):
  h = np.ones((L,L))  # criação de matriz L x L, todos elementos iguais a 1
  # Exibe a resposta ao impulso 
  h = h/np.sum(h) # normalização (é a versão que iremos usar na filtragem)
  im_output = cv.filter2D( im_gray, -1, h )  # convolução 2D (pesquise o que significa o parâmetro 'ddepth')
  print("Filtro com L = " + str(L))
  cv2_imshow(im_output)  # exibe a imagem colorida original

print("Imagem fonte")
cv2_imshow(im_gray)
printfiltro2D(3)
printfiltro2D(15)

"""3. Repita as duas questões acima para o filtro gaussiano 2D com $\sigma = 3$ e $\sigma = 9$. A resposta ao impulso deve estar centrada na matriz de suporte, cujas dimensões devem ser suficientes para conter os elementos compreendidos no intervalo de $−5\sigma$ a $5\sigma$ em torno da média nas duas dimensões."""

import numpy as np    
import matplotlib.pyplot as plt 
from matplotlib import cm
import cv2 as cv                  
from google.colab.patches import cv2_imshow
#from scipy.ndimage import gaussian_filter

# Implementação do filtro gaussiano 2D
M = 300 # número de pontos da FFT
for sigma in [3, 9]: # Implementando para sigma = [3, 9]
    size = int(5*sigma)
    media = size/2
    print("Implementação do filtro gaussiano 2D com sigma=", sigma)
    A = (1/np.sqrt(2*np.pi*(sigma**2)))
    x, y = np.mgrid[-size: size + 1, -size: size + 1]
    # Exibe a resposta ao impulso
    h1 = A*np.exp(( -(x-media)*2 - (y-media)*2)/(2*(sigma**2)))  
    sumh = h1.sum()
    h1 = h1/np.sum(h1) # normalização
    print('Resposta ao impulso normalizada: \n', h1)

    # Vetores de dados
    fig, ax = plt.subplots(subplot_kw={"projection": "3d"})

    # Traçado da superfície
    surf = ax.plot_surface(x, y, h1, cmap=cm.coolwarm,
                          linewidth=0, antialiased=False)

    plt.show()